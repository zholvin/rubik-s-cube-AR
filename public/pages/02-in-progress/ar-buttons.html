<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Rubik's Cube AR</title>
    <link rel="stylesheet" href="style/index.css" />
    <style>
        /* Control panel styling for on-screen move buttons */
        #move-buttons {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 999;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }
        #move-buttons button {
            margin: 5px;
            padding: 8px 12px;
            font-size: 14px;
        }
        /* Styling for the file upload label */
        #file-label {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
        }
        /* Hide the actual file input */
        #move-file {
            display: none;
        }
    </style>
</head>
<!-- Include A-Frame and AR.js libraries -->
<script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
<script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.min.js"></script>
<script>
    // Whole-cube controller
    AFRAME.registerComponent('rbscube-controller', {
        init: function () {
            let isAnimating = false;
            this.rotateWholeCube = () => {
                if (isAnimating) return;
                isAnimating = true;
                const rotation = this.el.getAttribute('rotation');
                const startY = rotation.y;
                const targetY = startY + 90;
                const step = 5;
                const interval = 10;
                let currentY = startY;
                let rotateInterval = setInterval(() => {
                    if (currentY < targetY) {
                        currentY += step;
                        this.el.setAttribute('rotation', { x: rotation.x, y: currentY, z: rotation.z });
                    } else {
                        clearInterval(rotateInterval);
                        isAnimating = false;
                    }
                }, interval);
                console.log('Whole cube rotated');
            };
        }
    });

    // Cube-controller component
    AFRAME.registerComponent('cube-controller', {
        schema: {
            speed: { type: 'number', default: 270 } // Speed in degrees per second
        },
        init: function () {
            this.faceMoveActive = false;
            this.isMoving = false;
            this.moveQueue = [];
            this.movePivot = null;
            this.moveAxis = null;
            this.totalAngle = 0;
            this.remainingAngle = 0;
        },
        handleFaceRotation: function(pivot, axis, angle) {
            if (this.isMoving) {
                this.moveQueue.push({ pivot: pivot.clone(), axis: axis.clone(), angle: angle });
                return;
            }
            this.startFaceRotation(pivot, axis, angle);
        },
        startFaceRotation: function(pivot, axis, angle) {
            this.faceMoveActive = true;
            this.movePivot = pivot.clone();
            this.moveAxis = axis.clone().normalize();
            this.totalAngle = THREE.MathUtils.degToRad(angle);
            this.remainingAngle = this.totalAngle;
            this.isMoving = true;
        },
        tick: function(_, deltaTime) {
            if (!this.faceMoveActive) return;
            const timeFactor = deltaTime / 1000;
            let step = THREE.MathUtils.degToRad(this.data.speed) * timeFactor;
            if (Math.abs(step) > Math.abs(this.remainingAngle)) {
                step = this.remainingAngle;
            } else {
                step = Math.sign(this.remainingAngle) * step;
            }
            const pos = this.el.object3D.position;
            pos.sub(this.movePivot);
            pos.applyAxisAngle(this.moveAxis, step);
            pos.add(this.movePivot);
            this.el.object3D.rotateOnWorldAxis(this.moveAxis, step);
            this.remainingAngle -= step;
            if (Math.abs(this.remainingAngle) < 0.001) {
                this.faceMoveActive = false;
                this.isMoving = false;
                if (this.moveQueue.length > 0) {
                    const nextMove = this.moveQueue.shift();
                    this.startFaceRotation(nextMove.pivot, nextMove.axis, nextMove.angle);
                }
            }
        }
    });

    // Move-manager component with 1-second delay
    AFRAME.registerComponent('move-manager', {
        init: function() {
            this.queue = [];
            this.isMoving = false;
        },
        addMoveToQueue: function(moveCode) {
            this.queue.push(moveCode);
            if (!this.isMoving) {
                this.processNextMove();
            }
        },
        processNextMove: function() {
            if (this.queue.length === 0) {
                this.isMoving = false;
                return;
            }
            this.isMoving = true;
            const moveCode = this.queue.shift();
            const face = moveCode[0].toLowerCase();
            let angle = moveCode.includes("2") ? -180 : moveCode.includes("'") || moveCode.includes("′") ? 90 : -90;
            let pivot, axis;
            switch(face) {
                case 'f': pivot = new THREE.Vector3(0, 0, 1); axis = new THREE.Vector3(0, 0, 1); break;
                case 'b': pivot = new THREE.Vector3(0, 0, -1); axis = new THREE.Vector3(0, 0, -1); break;
                case 'u': pivot = new THREE.Vector3(0, 1, 0); axis = new THREE.Vector3(0, 1, 0); break;
                case 'd': pivot = new THREE.Vector3(0, -1, 0); axis = new THREE.Vector3(0, -1, 0); break;
                case 'l': pivot = new THREE.Vector3(-1, 0, 0); axis = new THREE.Vector3(-1, 0, 0); break;
                case 'r': pivot = new THREE.Vector3(1, 0, 0); axis = new THREE.Vector3(1, 0, 0); break;
                default: console.error("Unknown move code: " + moveCode); this.isMoving = false; return;
            }
            const tolerance = 0.1;
            this.el.querySelectorAll('.cube').forEach(cube => {
                if (!cube.components || !cube.components['cube-controller']) return;
                const pos = cube.object3D.position;
                let belongs = false;
                switch(face) {
                    case 'f': belongs = Math.abs(pos.z - 1) < tolerance; break;
                    case 'b': belongs = Math.abs(pos.z + 1) < tolerance; break;
                    case 'u': belongs = Math.abs(pos.y - 1) < tolerance; break;
                    case 'd': belongs = Math.abs(pos.y + 1) < tolerance; break;
                    case 'l': belongs = Math.abs(pos.x + 1) < tolerance; break;
                    case 'r': belongs = Math.abs(pos.x - 1) < tolerance; break;
                }
                if (belongs) {
                    cube.components['cube-controller'].handleFaceRotation(pivot, axis, angle);
                }
            });
            setTimeout(() => {
                this.isMoving = false;
                this.processNextMove();
            }, 1000);
        }
    });

    // Trigger move function
    function triggerMove(moveCode) {
        const moveManager = document.querySelector('.RBsCube').components['move-manager'];
        moveManager.addMoveToQueue(moveCode);
    }

    // File upload handler
    document.addEventListener('DOMContentLoaded', function() {
        document.getElementById('move-file').addEventListener('change', function(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                const moves = parseMoves(content);
                const moveManager = document.querySelector('.RBsCube').components['move-manager'];
                moves.forEach(move => moveManager.addMoveToQueue(move));
            };
            reader.readAsText(file);
        });
    });

    // Parse moves from file content
    function parseMoves(content) {
        content = content.replace(/[\s,]+/g, '');
        const moveRegex = /([A-Za-z]['2]?)/g;
        const moves = content.match(moveRegex);
        return moves || [];
    }
</script>
<body style="margin: 0; overflow: hidden;">
<!-- File input with label for move sequence -->
<label for="move-file" id="file-label">Select Move File</label>
<input type="file" id="move-file" accept=".txt,.json,.csv" />

<!-- AR Scene -->
<a-scene embedded arjs="sourceType: webcam;" renderer="preserveDrawingBuffer: true;">
    <a-assets>
        <img id="my-image" src="../../image.png" />
        <a-asset-item id="cube" src="/models/RBsCubeWorldOriginCube.glb"></a-asset-item>
    </a-assets>
    <a-marker preset="hiro">
        <a-entity class="RBsCube" move-manager scale="0.5 0.5 0.5">
            <!-- Center pieces -->
            <a-gltf-model src="#cube" class="cube center" position="0 0 0" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube center" position="0 -1 0" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube center" position="0 1 0" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube center" position="0 0 1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube center" position="1 0 0" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube center" position="0 0 -1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube center" position="-1 0 0" cube-controller></a-gltf-model>
            <!-- Edge pieces -->
            <a-gltf-model src="#cube" class="cube edge" position="0 1 1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="1 1 0" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="0 1 -1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="-1 1 0" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="0 -1 1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="1 -1 0" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="0 -1 -1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="-1 -1 0" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="-1 0 -1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="1 0 -1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="-1 0 1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube edge" position="1 0 1" cube-controller></a-gltf-model>
            <!-- Corner pieces -->
            <a-gltf-model src="#cube" class="cube corner" position="1 1 1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube corner" position="-1 1 -1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube corner" position="1 1 -1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube corner" position="-1 1 1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube corner" position="1 -1 1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube corner" position="1 -1 -1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube corner" position="-1 -1 1" cube-controller></a-gltf-model>
            <a-gltf-model src="#cube" class="cube corner" position="-1 -1 -1" cube-controller></a-gltf-model>
        </a-entity>
    </a-marker>
    <a-entity camera></a-entity>
    <a-text value="Dev Mode" position="-0.5 1 -10"></a-text>
    <a-text value="Use on-screen buttons or file upload for moves" position="-1 0.5 -10"></a-text>
    <a-text value="(Hint: Hiro marker is available)" position="-1.5 0 -10"></a-text>
</a-scene>

<!-- On-screen control panel with move buttons -->
<div id="move-buttons">
    <button data-move="F" onclick="triggerMove(this.getAttribute('data-move'))">F</button>
    <button data-move="F'" onclick="triggerMove(this.getAttribute('data-move'))">F′</button>
    <button data-move="F2" onclick="triggerMove(this.getAttribute('data-move'))">F2</button>
    <button data-move="B" onclick="triggerMove(this.getAttribute('data-move'))">B</button>
    <button data-move="B'" onclick="triggerMove(this.getAttribute('data-move'))">B′</button>
    <button data-move="B2" onclick="triggerMove(this.getAttribute('data-move'))">B2</button>
    <button data-move="U" onclick="triggerMove(this.getAttribute('data-move'))">U</button>
    <button data-move="U'" onclick="triggerMove(this.getAttribute('data-move'))">U′</button>
    <button data-move="U2" onclick="triggerMove(this.getAttribute('data-move'))">U2</button>
    <button data-move="D" onclick="triggerMove(this.getAttribute('data-move'))">D</button>
    <button data-move="D'" onclick="triggerMove(this.getAttribute('data-move'))">D′</button>
    <button data-move="D2" onclick="triggerMove(this.getAttribute('data-move'))">D2</button>
    <button data-move="L" onclick="triggerMove(this.getAttribute('data-move'))">L</button>
    <button data-move="L'" onclick="triggerMove(this.getAttribute('data-move'))">L′</button>
    <button data-move="L2" onclick="triggerMove(this.getAttribute('data-move'))">L2</button>
    <button data-move="R" onclick="triggerMove(this.getAttribute('data-move'))">R</button>
    <button data-move="R'" onclick="triggerMove(this.getAttribute('data-move'))">R′</button>
    <button data-move="R2" onclick="triggerMove(this.getAttribute('data-move'))">R2</button>
</div>
</body>
</html>